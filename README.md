# SNHU CS 499 Computer Science Capstone

Hello! My name is Taryn, and welcome to my ePortfolio! Prior to my time at SNHU, I received my B.S. in Aerospace Engineering at Texas A&M. There, I learned all about the engineering process, including requirements determination and working to requirements, professional documentation and presentation, and how to consider engineering realities (materials, costs, risk analysis, etc.). After graduating, I began working at NASA Johnson Space Center, where I currently work as a Training Systems Operator/System Analyst. I have enjoyed what little coding I did both in school and in my career, so I decided to pursue a B.S. in Computer Science at SNHU. While doing so, I learned how to apply those same engineering principles I learned in aerospace instead to the development of professional code, building on my previous engineering experience both in academia and at NASA. Together, aerospace engineering and computer science have taught me how to take a problem, design a solution, and then work to build a goal-oriented, well-formed, and well-documented product that meets or exceeds (or sometimes changes, as engineering projects often do) the proposed solution.
Whether working alone or as part of a team, I believe that professional communication and documentation is paramount. Guido Van Rossum, the creator of Python, noted that, "Code is read more often than it is written." Even in my personal projects, I document my thought processes and code, so that should I return to them later, I can pick up where I left off and retrace my thoughts. When working as part of a team, this skill becomes even more important. I did not get to work with groups often at SNHU, but I have plenty of experience with teamwork from my time at Texas A&M and NASA. I was proud to work alongside two friends and aerospace colleagues for my senior capstone project, which was a paper project to design a Mars colony, and at NASA I have taken on a leadership role in my team as the backup lead for TSO, serving as the lead whenever our current lead is away.
In addition to a standard of excellence in documentation, I learned to keep security in mind when writing code. Security is not, I believe, the final step to tack on to a project once it is mostly complete, but rather something that should be built-in wherever possible from the very beginning. Writing secure code from the get-go can prevent massive code rewrites or hastily applied patches down the line.
This ePortfolio hopefully serves as a demonstration of many of the skills I learned in my computer science education. The original artifact is a simple text-based game written in Python. It is from early on in my coursework, from IT-140. I believe it shows some early understanding of good coding practices. For instance, in order to play the game, the player has to type commands into the terminal, such as "Go North" or "Get mushrooms," and I did include some input validation to make sure that misspelling a command did not crash the program. The final product has been enhanced in three categories: software design and engineering, data structures and algorithms, and databases.
For the first category, I decided to redesign the game to have a GUI rather than play in the terminal. To do this, I had to completely restructure my code around tkinter, which was an interesting challenge and learning experience, as I had never built a GUI before. I drew up a sample screen of what I intended to build, and worked to implement that. As the project went on, I designed several additional screens, including a start menu, a page to view high scores, and three separate game over pages (one for losing, one for winning with a high score, and one for winning without a high score).
For the data structures and algorithms category, I added a scoring method that was not present in the original game, and restructured the game to include two classes, rather than the global variables I had been using for development and testing. The original game has the player navigate around a small, static map, gathering items before entering a final room. If the final room is entered before all the necessary items are gathered, the player loses. If the player has all the items prior to entering the final room, they win. For my scoring system, I created three separate lists of items. Each room with an item has one item from each list, and the player can select only one item. Different items are worth different points, and combinations of items from the same list provide a multiplier. If a player gathers items from only one list, they receive a "perfect" bonus. Finally, the game can be completed in a minimum of twelve movements, and any movements beyond that are penalized. When the player enters the final room with any combination of six items, they win, and their score is calculated.
Finally, to enhance my artifact with a database, I added a database for high scores and player names. Up to ten entries are recorded. If fewer than ten entries exist in the database, scores and player names will be recorded until ten entries are reached. After that, if a player scores higher than the lowest score in the database, their name and score is recorded over the lowest scoring entry. These player names and high scores can be viewed in the GUI.
I would like to mention a couple of notes on the code. First, I noted in my code review that, while I tried to adhere to some basic coding best practices, my initial artifact did not strictly adhere to any coding standard. For my final project, I decided to adhere to the PEP 8 Style Guide for Python (https://peps.python.org/pep-0008/). Additionally, because my code receives user input (players are prompted to input their name), SQL injection was a concern. For this reason, I implemented some input sanitization, to account for that security concern.
With all that said, please enjoy GUI Stew!
